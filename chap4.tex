%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Webauthn Firewall Design}

The webauthn firewall acts as a Web Application Firewall (WAF). It is situated directly between the frontend and backend, processing all user requests sent between the two. Each requests gets parsed by the firewall, and understood whether it is a request that needs webauthn transaction authentication or not. If not, the request is simply proxied through to the backend without any extra work. However, if it needs transaction authentication, the firewall acts as a gatekeeper for that request. The firewall performs a verification procedure on the request and only upon success does the request pass through the firewall to the backend. If it fails, the firewall returns an error back to the frontend. This design strategy for integrating webauthn transaction authentication into a service is very powerful because it is web service agnostic. The backend is completely unaware that the requests it receives are webauthn authenticated. Of course, since the frontend has to interface with the user's hardware authenticator device, it must be aware of webauthn, but only to a minor extent. 

\subsection{Proxying Requests}

In three different case studies, the firewall was used to integrate webauthn transaction authentication into two different paradigms of web service designs, RESTful and server-side rendered websites. For each, the notion of the firewall being situated between the frontend and backend is slightly different, but the function and role of the webauthn firewall is the same, filtering, verifying and proxying requests. 

%% TODO: Image of RESTful firewall

For a RESTful web application, the placement of the firewall is more intuitive. In a RESTful design, frontend and backend are separate programs running on their own IP addresses and ports. The user's web-browser interacts with the frontend through its IP address. And whenever the frontend needs to interact with the backend, it launches HTTP requests to the IP address of the backend. However, the webauthn firewall must sit in between the two. So, the firewall runs on its own IP address and port, and the frontend is reconfigured to use it as its backend address destination. So when the frontend needs to issue a backend request, it sends it rather to firewall rather than the backend. From there, the firewall performs its role and, as necessary, proxies onward to the actual backend. Responses from the backend are returned to the firewall which are automatically forwarded on to the frontend. 

%% TODO: Image of server-side firewall

In a server-side rendering web application, the firewall additionally performs the role of the frontend described in the RESTful use case. That is, the user's web-browser interacts with the IP address of the firewall directly. All HTTP requests originate from the user's web-browser and are directed to whatever the address is of the frontend. In a server-side rendering web application, the whole service, the frontend and backend, is served out of the same address. With the webauthn firewall, requests get sent to the firewall which again does its role and, if necessary, relays onward to the server-side rendering web-application. In this case, the webauthn firewall is situated between the web-browser and backend. But nonetheless, it is the same principle as with the RESTful web application use case. An origin, in this case the web-browser, issues requests destined for a backend, but they get intercepted by the firewall, before they continue on if everything succeeds.

\subsection{Webauthn Firewall Configuration}

%% TODO: Make option in firewall to either pass through or block non-specified requests. Modify this paragraph

As the webauthn firewall filters requests sent to it, some requests will be held back to be webauthn transaction authenticated first. Which requests get held back and what their authentication messages are is configured in the firewall by the software engineer. In order to specify which HTTP route get filtered out and transaction authenticated, the engineer simply includes the route in the firewall's configuration. All other routes not specified in the configuration are simply passed on through to the backend without any checks.

\subsubsection{Configuration Parameters}

The webauthn firewall has a number of configurable parameters that aid and dictate how routes get secured. The following is the firewall configuration for Conduit:

\begin{lstlisting}
  firewallConfigs := &wf.WebauthnFirewallConfig{
    RPDisplayName: "Foobar Corp.",
    RPID:          "localhost",

    FrontendAddress:       frontendAddress,
    ReverseProxyTargetMap: reverseProxyTargetMap,
    ReverseProxyAddress:   reverseProxyAddress,

    GetUserID: userIDFromJWT,
    ContextGetters: wf.ContextGettersType{
      "comment":      commentFromCommentID,
      "article":      articleFromArticleSlug,
      "current_user": getCurrentUser,
    },

    WebauthnCorePrefix: "/api/webauthn",
    LoginURL:           "/api/users/login",
    LoginGetUsername: func(r *wf.ExtendedRequest) (string, error) {
      return r.Get_WithErr("user", "username")
    },

    SupplyOptions: true,
    Verbose:       true,
  }
\end{lstlisting}

The fields within the configuration are grouped by function. The first group, \lstinline{RPDisplayName} and \lstinline{RPID}, is used by the webauthn library when setting up and verifying transaction authentication events. 

\noindent The second group contains the proxying address information. 

\begin{itemize}[nosep]
\item \lstinline{FrontendAddress}: Set to the frontend address. In a RESTful context, that is the frontend itself. In a server-side context, since the firewall functions as the frontend, it should be the firewall's address.

\item \lstinline{ReverseProxyTargetMap}: A hash map of hosts and targets, along with their respective default input getters described in Section~\ref{Sec:DefaultInputGetters}. This field configures the firewall to catch requests of a given \lstinline{host} and forward it to a specific \lstinline{target}. There are separate default input getters since requests going to different hosts may have different representations of their payloads. The following code snippet is the \lstinline{ReverseProxyTargetMap} from the firewall configuration for Calypso.

\item \lstinline{ReverseProxyAddress}: Set to the address where the firewall should attach and listen on.
\end{itemize}

\begin{lstlisting}
// wf.NewProxyTarget(host, target, defaultInputGetter)
reverseProxyTargetMap = 
  wf.NewProxyTarget("public-api.wordpress.com", 
                    "https://workaround-public-api.wordpress.com", 
                    wf.GetJSONInput).
  AnotherTarget("wordpress.com", 
                "https://workaround.wordpress.com",
                 wf.GetFormInput)
\end{lstlisting}

In this case, requests destined for \lstinline{"public-api.wordpress.com"} get forwarded to \\ \lstinline{"https://workaround-public-api.wordpress.com"} and have JSON payloads. Requests destined for \lstinline{"wordpress.com"} get forwarded to \lstinline{"https://workaround.wordpress.com"} and have form-data inputs. 

%% 
\iffalse
The \lstinline{FrontendAddress} should naturally be set to the

The \lstinline{ReverseProxyTargetMap} is a hash map of hosts and targets, along with their respective default input getters described in Section~\ref{Sec:DefaultInputGetters}. This field tells the firewall to catch requests of a given \lstinline{host} and forward it to a specific \lstinline{target}. There are separate default input getters since requests going to different hosts may have different representations of their payloads. The following is the \lstinline{ReverseProxyTargetMap} from the firewall configuration for Calypso:

The \lstinline{ReverseProxyAddress} should be set to the address where the firewall should attach itself and listen on.
\fi
%% 

\noindent The third group is for context retrieval, explained in greater detail in Section~\ref{Sec:ContextRetrieval}. 

\begin{itemize}[nosep]
\item \lstinline{GetUserID}: A function that, given an HTTP request, extracts the current logged in user's ID. Since this is very application specific, it is up to the engineer to implement this function.

\item \lstinline{ContextGetters}: A hash map of context tags and context getter functions. When the engineer sets up routes to protect, there is a clean way to invoke these functions by tag to retrieve more context as needed.
\end{itemize}

%% 
\iffalse

The \lstinline{GetUserID} is a function that, given an HTTP request, extracts the current logged in user's ID. Since this is very application specific, it is up to the engineer to implement this function. The \lstinline{ContextGetters} is a hash map of context tags and context getter functions. When the engineer sets up routes to protect, there is a clean way to invoke these functions by tag to retrieve more context as needed.

\fi
%% 

\noindent The fourth group is to configure the default handlers, explained in more detail in Section~\ref{Sec:DefaultHandlers}. When integrating webauthn into a service, there are a number of operations that are a core part of the webauthn protocol. They are related to the webauthn registration event, the setup event, user login and webauthn disable. 

\begin{itemize}[nosep]
\item \lstinline{WebauthnCorePrefix}: Specifies the prefix for all URL routes of core webauthn events. In this case, for example, the webauthn setup route is found at \lstinline{"/api/webauthn/begin_attestation"}.

\item \lstinline{LoginURL}: The url route where the applications POSTs to during login.

\item \lstinline{LoginGetUsername}: A special function that extracts the username from the login HTTP request's payload.

\end{itemize}

%% 
\iffalse

The \lstinline{WebauthnCorePrefix} specifies the prefix for all URL routes of core webauthn events. In this case, for example, the webauthn setup route is found at \lstinline{"/api/webauthn/begin_attestation"}. The \lstinline{LoginURL} is the url route where the applications POSTs to during login. The \lstinline{LoginGetUsername} is a special function that extracts the username from the login HTTP request's payload.

\fi
%% 

\noindent The final group contains miscellaneous parameters.

\begin{itemize}[nosep]

\item \lstinline{SupplyOptions}: A boolean flag specifying whether protected routes should respond with an HTTP OPTIONS verb or not.

\item \lstinline{Verbose}: A boolean flag specifying whether the firewall should log the HTTP requests it processes.

\end{itemize}

%% 
\iffalse

The \lstinline{SupplyOptions} is a boolean flag specifying whether protected routes should respond with an HTTP OPTIONS verb or not. The \lstinline{Verbose} is a boolean flag specifying whether the firewall should log the HTTP requests it processes.

\fi
%% 

\subsubsection{Default Input Getters}\label{Sec:DefaultInputGetters}

An HTTP request may contain and encode its payload in a variety of ways. The firewall supplies four default input getter functions that extract values from requests in different formats. Each default input getter follows the same API, so new ones can be implemented quite easily as necessary. The getters include:

\begin{itemize}[nosep]
\item \lstinline{GetFormInput}: Parses form-data request payloads

\item \lstinline{GetURLInput}: Parses values stored in the HTTP request url. An example would be \lstinline{"/user/comment/6"} parsing the comment ID \lstinline{6} from the URL

\item \lstinline{GetJSONInput}: Parses JSON request payloads

\item \lstinline{GetURLParamInput}: Parses parameters passed along with the HTTP request url. An example would be \lstinline{"/user/comment?id=9"} parsing the comment ID \lstinline{9} from the URL

\end{itemize}

\subsubsection{Context Retrieval}\label{Sec:ContextRetrieval}

%% TODO maybe include some image, incoming ID in request, firewall gets context

When an HTTP request contains non-human friendly identifiers that need to be understood by the user, those identifiers must be translated to their human readable counterparts. For example, an ID identifies a user's comment to a blog post in the Conduit application. Showing the ID in an authentication message is meaningless to the user. So rather the ID must be translated to the comment's title which the user can comprehend. This translation is handled by context getter functions programmed by the engineer. Generally, fetching context involves querying the backend for the extra information. This is necessary whenever the frontend does not have complete context of the items it displays. The following is a summarized code snippet of the Conduit comment context getter that accesses the backend.

\begin{lstlisting}
func commentFromCommentID(args ...interface{}) interface{} {
  var comments struct {
    Comments []wf.StructContext `json:"comments"`
  }

  // Extract the `args` to meaningful variable names
  slug := args[0].(string)
  commentID := args[1].(int64)

  // Perform the request to retrieve all of the comments for a given `slug`
  url := fmt.Sprintf("%s/api/articles/%s/comments", backendAddress, slug)
  tool.GetRequestJSON(url, &comments)

  // Search for the comment with `commentID`
  for _, comment := range comments.Comments {
    if comment["id"] == commentID {
      return comment
    }
  }
  
  // Comment not found
  return fmt.Errorf("Comment ID %d not found", commentID)
}
\end{lstlisting}

\iffalse

, and by consequence the firewall, do not have complete knowledge of the items they

\fi

\subsubsection{Default Handlers}\label{Sec:DefaultHandlers}

There are a number of core webauthn operations that are constant regardless of the application. These operations are automatically secured by the firewall internally without the engineer programming anything. They include:

\begin{itemize}[nosep]
  %% TODO: The use of Enable Webauthn and Disable Webauthn buttons is kinda generic
\item \lstinline{webauthnIsEnabled}: The frontend can query the firewall to see if a user has webauthn enabled or not. This is primarily used in the security settings panel of the frontend to determine whether to  have an ``Enable Webauthn'' or ``Disable Webauthn'' button.

\item \lstinline{beginRegister}: Handles the setup for a webauthn registration event.

\item \lstinline{finishRegister}: Accepts a user's hardware authenticator credentials during the finishing phase of webauthn registration.

\item \lstinline{beginLogin}: Handles the setup for a simple webauthn two-factor authentication during user login.

\item \lstinline{finishLogin}: Handles the verification of the webauthn two-factor authentication for user login.

\item \lstinline{beginAttestation}: Handles the setup for a regular webauthn transaction authentication event.

\item \lstinline{disableWebauthn}: Handles the verification of a transaction authenticated disable webauthn event.

\end{itemize}

\subsubsection{Domain Specific Language}

Following the default handlers, the majority of the firewall's routing configuration is performed using a domain specific language. 



\subsection{Webauthn Verification}

\subsubsection{Authentication Message}\label{Sec:AuthenticationMessage}

Of the requests that need to be checked, the engineer must specify their authentication message format. In essence, verifying an incoming HTTP request with transaction authentication involves the firewall generating an authentication message from the parameters of the request. Then the verification passes only if the generated message is exactly identical to the message signed by the hardware authenticator and the signature is valid.

The message generated by the firewall represents the root of truth and should encapsulate the entire intent of the request in order to have good security guarantees. All of the parameters in the requests that are considered security sensitive must appear unambiguously in the authentication message in a human readable format. Unambiguity refers to how no two different requests should share the same authentication message. Human readability is critical since the user is the one authenticating the message and sometimes the parameters in the request may be not human intelligible such as object IDs, etc.

\iffalse
is reconfigured to issue backend requests to the IP address

Upon opening the web page, requests are issued from the web-browser

has two options to specify how a route gets verified.

This message should encapsulate 

also included in the request and the associated signature is valid.
\fi
