%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{WebAuthn Transaction Authentication}\label{Chap:WebauthnTransactionAuthentication}

WebAuthn transaction authentication is a protocol specification for authenticating high-risk user operations, even after login. The specification describes a sequence of steps that must be followed in order to authenticate properly. These steps can be split into four stages: registration, the setup, the cryptographic attestation and then the verification. 

%% 
%% \iffalse
%% store later accessible to the verification code and is performed only once per user.
%% \fi
%% 

\begin{enumerate}[nosep]
\item Registration: Makes a record of the user and their cryptographic credential into a database. Registration is only performed once per user, and the database record is used by the verification step later on.

\item Setup: Initiated by the user's web-browser and involves a priming exchange between it and the WebAuthn verification end.

\item Cryptographic Attestation: Occurs on the hardware authenticator device after the user confirms the operation. The threat model assumes that this attestation is secure.

\item Verification: Validates whether to authorize the high-risk user operation or not. Checks if the requested operation matches its authentication message and that the cryptographic signature on it is valid. This stage also is assumed secure under the threat model.

\end{enumerate}

The rest of this chapter describes these steps in more detail and uses the WebAuthn firewall as the verification end. It contains the database of user public key credentials and performs the validation to authorize high-risk operations or not. 

%% 
%% \iffalse
%% This outline for transaction authentication 

%% As webauthn is a protocol specification, nothing dictates this design choice. However, for continuity with the thesis work, the protocol is best explained with the firewall.
%% \fi
%% 

%% 
%% \iffalse
%% between the user and hardware authenticator device. 

%% Lastly, the verification stage 
%% Occurs within the firewall, and it 
%% \fi
%% 

\section{WebAuthn Registration}

%% https://swimlanes.io/#fZFNboMwEIX3PsUcoFwgqioliFU3FZWa9WC/BEtgt/aQiNtnSDYQSrZ+P36fZj9IiyDessRE70XxQUc0xSHFa0baUZWFm87nlsoYAqz4GIyZWUgTP0j+NFWoSFVwO/qGDL9U429AFmNCFPzjKhNYBQ6OEnr0jdbZlruOwxlkzHOCnteVkxlqXk3az7kWxoWyavwalNbSJ8a3F+1rlI3cBvj9ZVRoC3+Be0BPCepZbItMWcfNhc2qGjYmN/ufJJJjvRpn3AA=
%% Zoom in to 200% on web-browser and screenshot, convert to pdf
\begin{figure}[h]
  \centering
  \includegraphics[width=16cm]{registration_flow_swimlanes}
  \caption{The flow of events during WebAuthn registration.}
  \label{Fig:WebauthnRegistrationFlow}
\end{figure}

Figure~\ref{Fig:WebauthnRegistrationFlow} illustrates the flow of events during the registration event. The purpose is for the user's hardware device to transfer its public key credential to the firewall. This process is assumed to be secure in the threat model, with no adversary to intercept or tamper with any of the communication. Therefore, whatever credential the firewall receives during registration is assumed to be genuine and the user's. The firewall later on uses this credential during the verification stage to ensure transaction authentication integrity. 

%% 
%% \iffalse
%% \begin{lstlisting}
%% type PublicKeyCredentialCreationOptions struct {
%% 	Challenge              Challenge                
%% 	RelyingParty           RelyingPartyEntity       
%% 	User                   UserEntity               
%% 	Parameters             []CredentialParameter
%% 	AuthenticatorSelection AuthenticatorSelection
%% 	Timeout                int                      
%% 	Attestation            ConveyancePreference
%% }
%% \end{lstlisting}
%% \fi
%% 

The registration process begins with a setup of its own, where the web-browser requests a few parameters from the firewall, most notably a random challenge nonce. The firewall remembers the challenge it sent as a part of the session data associated with the registration setup request. The challenge nonce prevents replay attacks \cite{TODO-replay-attack}. There are a few other parameters, but they are mainly for the hardware device to know what type of credential the firewall is expecting to receive. The hardware device sends over its public key credential for the firewall to save, with the challenge signed by that credential. The firewall receives an HTTP POST request containing this public key credential. The POST request also contains identifying information of the current user. The firewall verifies that the challenge is matches, and upon success, stores the credential and associated user ID into a database row.

\section{Transaction Authentication Setup}\label{Sec:TransactionAuthenticationSetup}

%% https://swimlanes.io/#nVPJTsNADL3nK/wBlA+oEFJbVXAACdECx8qZuMkozUyYcbr8Pc6mLKVAuUWTt9h+9qzghAxrhWwd3E0m9/BB4WTu7MGTm8LSM4Y77RNYWGNIsbYmCDZTWBEXOawYYwoCY5mGvIUjlDfs5IUIGXlfEXpYEMt3cnrbgpYmauVf6bMgzzcwG+o8tzqV8Tm7dTcROMooC8VGJbjboYkJgmDMgHHbixJMAr6B5ZHJeAF6OGhOqlLMbVfCprQ75Wxjh3miFcyYpWasJzVqdNYf91U2Vacj+lupqqzZapd5sDm5xnWAO2tupWODXDhxva7Pwdia6H9N8nG9fumC/J/3hZirlxNwglzHW6pBhqwS8uCld4q6HxdlHsiUk+tvq+ZuWyFELzryUI06LtopX1q+hFRaF+VIkd4LGeuGWsW2xLhxHgMuaj9Zm4IcRlGOOy/kMhWkdAJtIEK5VKn0qrp8GwdoD3vc6ej745ijSkk+V+T25Qr1Q20Mx5DlkVQhlzDCDmE/rozPZSHoD9c6wH8B
%% Zoom out to 90% on web-browser and screenshot, convert to pdf
%% :screenshot --selector .diagram --filename /tmp/txauthn_flow.png (in firefox console)
\begin{figure}[h]
  \centering
  \includegraphics[width=12.5cm]{txauthn_flow_swimlanes}
  \caption{The flow of events during WebAuthn transaction authentication, subdivided into three stages.}
  \label{Fig:TxAuthnFlow}
\end{figure}

% TODO: Talk about server-side rendering preloading

The setup for a transaction authenticate event originates from the frontend. Figure~\ref{TxAuthnFlow} illustrate the setup stage of a transaction authentication event. There are several designs to setup a WebAuthn transaction event, but the setup content itself is all the same. More commonly, setup may occur lazily where the frontend waits for the user to initiate an operation protected by transaction authentication before initiating the setup. Or it may occur eagerly where the frontend preemptively initiates the setup, without knowing whether the user will even perform any secured operation on the web-page. 

In either case, the setup is a POST request to the firewall. The payload for the setup POST request is an authentication message that will eventually be displayed to the user on their hardware device. The message is constructed from user input and additional information contained in the HTML of the webpage, but in all three case studies of this thesis, that was always enough. In response to the POST request, the frontend receives a few parameters:

%% 
%% \iffalse
%% \begin{lstlisting}
%% type PublicKeyCredentialRequestOptions struct {
%% 	Challenge          Challenge                   
%% 	Timeout            int                         
%% 	RelyingPartyID     string                      
%% 	AllowedCredentials []CredentialDescriptor      
%% 	UserVerification   UserVerificationRequirement 
%% 	Extensions         AuthenticationExtensions    
%% }
%% \end{lstlisting}
%% \fi
%% 

\begin{enumerate}[nosep]
\item A random \lstinline{challenge} nonce: The firewall remembers it locally in the session data associated with the request. When the firewall processes the protected request, it will verify that the challenge included in the returned authentication data matches the one previously sent and remembered in the session. An adversary cannot intercept and replay old protected requests since it is exceedingly unlikely that future challenges from the firewall will exactly match the challenge in the intercepted request.

\item An \lstinline{extensions} field: The firewall transforms the authentication message sent to it into a WebAuthn-compatible form for the hardware authenticator. It then emplaces it into the \lstinline{extensions} field, which the authenticator reads and handles as a transaction authentication operation.

\end{enumerate}

%% 
%% \iffalse
%% This field contains the authentication message. The firewall transforms this message into a webauthn-compatible form for the hardware authenticator device., so that the device
%% \fi
%% 

%% 
%% \iffalse
%% There are other fields returned as a part of the setup, but they are mostly for plumbing. They delineate how the hardware device should respond when authenticating the webauthn transaction.
%% \fi
%% 

%% 
%% \iffalse
%% The other fields are mostly for plumbing. The \lstinline{Timeout} requires an authentication response with that amount of time. The \lstinline{RelyingPartyID} identifies the backend. The \lstinline{AllowedCredentials} identifies with which cryptographic key the user can sign the response. The \lstinline{UserVerification} tells the hardware authenticator that the user must physically confirm ``yes'' or deny ``no'' a request and is usually set to \lstinline{true}. The \lstinline{Extensions} includes a signal that transaction authentication is to be performed with the authentication message sent to the firewall.
%% \fi
%% 

\section{Cryptographic Attestation}\label{Sec:CryptographicAttestation}

The request options from the firewall go through the frontend and are passed on to the hardware authenticator device. The threat model assumes that only the firewall, backend and hardware authenticator are secure. At any point, the frontend or web-browser could modify these options, but any tampering will be detected later on and denied authorization. 

Figure~\ref{Fig:TxAuthnFlow} outlines the role of the hardware authenticator. The hardware device parses the request options, extracts from the \lstinline{extensions} field the authentication message and presents that to the user. The authentication message is in the form of a confirmation for some requested operation and is answered either by ``yes'' or ``no''. If the user attests ``yes'', the hardware device cryptographically signs a data object, which is returned as an additional field within the HTTP request to the firewall for verification.

The response of the hardware authenticator includes a \lstinline{clientDataJSON} object containing the authentication message displayed to the user a well as the \lstinline{Challenge} from the setup stage. A cryptographic signature of the \lstinline{clientDataJSON} is also included. The signature is computed using Elliptic Curve Digital Signature Algorithm (ECDSA) paired with the SHA-256 hash function. There are other fields, as well, for plumbing to help the firewall know what parameters to use to validate this response.

%% 
%% \iffalse
%% % TODO: Make this typescript highlighting
%% \begin{lstlisting}
%% const credential: PublicKeyCredential = {
%%     id: string, // base64 encoded
%%     rawId: []bytes,
%%     response: {
%%         attestationObject: []bytes,
%%         clientDataJSON: {
%%             challenge: string, // base64 encoded
%%             clientExtensions: []bytes,
%%             hashAlgorithm: string,
%%             origin: string,
%%         },
%%     },
%%     type: 'public-key',
%% };
%% \end{lstlisting}

%% The \lstinline{clientDataJSON} contains the \lstinline{clientExtensions} which is the data displayed to the user as well as the \lstinline{challenge} from the setup stage. The cryptographic signature of the \lstinline{clientDataJSON} is included in the \lstinline{attestationObject} and uses the Elliptic Curve Digital Signature Algorithm (ECDSA) paired with the SHA-256 hash function. The other fields are for plumbing and help the firewall know what parameters to use to validate this authentication data object.
%% \fi
%% 

\section{WebAuthn Firewall Verification}\label{Sec:WebauthnFirewallVerification}

The WebAuthn firewall receives an HTTP request on a protected route with all of its usual parameters plus the authentication data object. The firewall must verify the integrity of this object as well that it corresponds with the intent of the HTTP request. In other words, it must detect whether any code not in the trusted computing base, such as the frontend, tampered with the authentication data. Also, it must make sure that the operation the user attested to on their hardware device that resulted in this authentication data object is in fact the operation to be performed if the protected HTTP request were to be permitted through. 

Figure~\ref{Fig:TxAuthnFlow} illustrates the main steps of the verification stage. The three main steps are verifying the challenge, the authentication message and the authentication data signature:

\begin{enumerate}[nosep]

\item Checking the challenge is a simple comparison between the challenge received \lstinline{challenge} and the \lstinline{storedChallenge} in the firewall's session data. This protects against replay attacks.

%% 
%% \iffalse
%% \begin{lstlisting}
%% // Verify the challenge
%% Challenge := c.ClientDataJSON.Challenge
%% if strings.Compare(storedChallenge, Challenge) != 0 {
%% 	err := ErrVerification.WithDetails("Error validating challenge")
%% 	return err
%% }
%% \end{lstlisting}
%% \fi
%% 

\item Checking the authentication message is more involved. The firewall is configured per route how to generate an expected authentication message based on the HTTP request parameters. This generated authentication message must unambiguously encapsulate the entire intent of the request. Details are further discussed in Section~\ref{Sec:AuthenticationMessage}. Then it is a simple comparison between the received \lstinline{clientMessage} and the \lstinline{generatedMessage}. This makes sure the user authenticated a message that faithfully represents the intent of the HTTP request.

%% 
%% \iffalse
%% \begin{lstlisting}
%% // Verify the authentication message
%% clientMessage := c.ClientDataJSON.Extensions["txAuthnSimple"]
%% if strings.Compare(generatedMessage, clientMessage) != 0 {
%% 	err := ErrVerification.WithDetails(
%%               "Error validating authentication message")
%% 	return err
%% }
%% \end{lstlisting}
%% \fi
%% 

\item Checking the authenticating data signature involves invoking cryptography library utilities. This validates the integrity of the entire authentication object to prove that it was not tampered with. The \lstinline{clientDataJSON} was signed by the hardware authenticator. The firewall has the public key of the hardware authenticator, so it can see if the \lstinline{clientDataJSON} indeed corresponds to the signature attributed to it.

\end{enumerate}

%% 
%% \iffalse
%% \begin{lstlisting}
%% // Verify the signature

%% // The data signed by the hardware authenticator
%% clientDataHash := sha256.Sum256(c.ClientDataJSON)
%% sigData := append(p.Raw.AssertionResponse.AuthenticatorData, 
%%                   clientDataHash[:]...)

%% // The user's public key stored in the firewall
%% key, err := webauthncose.ParsePublicKey(credentialBytes)
%% valid, err := webauthncose.VerifySignature(
%%                  key, sigData, p.Response.Signature)
%% if !valid {
%% 	return err
%% }
%% \end{lstlisting}

%% Setup can occur eagerly where the web-browser immediately performs the setup without the user initiating any operation protected by transaction authentication.

%% If not, it will deny the request from continuing through.

%% The frontend only has access to the information it displays in the HTML to the user, 

%% The data displayed to the user along with its respective signature is included in the \lstinline{response} field. The hardware device signs
%% \fi
%% 
